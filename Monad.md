# 함수언어 입문자를 위한 모나드 해설

함수언어, 특히 하스켈과 같은 순수함수언어 계열을 다룰때는 반드시 마주체기 되며,
스칼라와 같은 하이브리드 언어를 사용하더라도 한번쯤은 관심을 가지게 되는 괴물(?)이 있으니 
바로 _모나드(Monad)_ 이다.

모나드에 대해 설명하는 튜토리얼을 들여다 보더라도 이해하기 쉽지가 않다. 
물론 대부분 영어로 되어있기 때문이라는게 첫번째 이유이고, 
두번쨰 이유는 추상적인 모나드 구조와 실제 우리가 코딩하는 코딩의 요소들 사이의 관계에 대해 
자세히 풀어 설명해주는 글이 드물다는 것이 두번쨰 이유이다. 

물론 스칼라에서 `map`과 `flatMap`이 정의된 클래스들을 `for`와 `yield`라는 
편리문법(syntactic sugar)과 결합해서 편리하게 다루는 것을 이미 본 사람이라면 
모나드가 뭔가 좋은일(?)을 하는 것이라는 정도는 알고 있지만, 
왜 대체 모나딕 룰이 필요한 건지, 대체 `flapMap`과 `map`이 둘 다 필요한 이유는 무엇인지 등등이 
궁금할 것이다.

나 또한 모나드를 100% 이해했다고는 할 수 없지만, 그간 들여다본 것을 바탕을
나름대로 모나드에 대해 설명해 보고자 한다. 독자 여러분도 이 글을 100% 신뢰하지 말고 
비판적으로 읽기 바란다.


## 값을 감싼 타입 만들기

기본적으로는 어떤 값을 감싼 다른 타입을 만드는 것에서 이 모든 일이 비롯된 것이다.
어떤 값을 감싸는 이유는 외부에 대해 그 값을 감추거나(정보은닉), 
감싸면서 어떤 정보를 추가하거나, 추가적인 연산을 정의하기 위한 것이다.

스칼라에서 어떤 값을 감싼 타입을 만드는 가장 쉬운 방법은 케이스 클래스를 활용하는 것이다.

아래 코드는 단순히 `T` 타입의 값을 감싼 타입인 `Boxed[T]`로 바꿔주는 케이스 클래스를 정의한다.

```
case class Boxed[T](value:T);
```

물론 이 클래스는 별로 유용하지는 않다. 조금 더 유용한 클래스를 만든다면, 스칼라의 `Option` 클래스와 
같은 것을 들 수 있다. `Option`이라는 이름이 의미하듯, 이 클래스는 어떤 값이 존재하거나(이때는 
`Some(value)`라는 타입이 된다), 어떤 값이 존재하지 않는(이때는 `None`이라는 하위 타입이 된다)
스칼라에서는 이런 경우 추상 클래스와 이를 상속한 하위 클래스들로 구현하게 된다.

```
abstract class Option[+A]

case class Some[+A](x: A) extends Option[A]

case object None extends Option[Nothing] 
```

다른 형태로는 컬렉션이 있다. 기본적 컬렉션의 하나인 리스트를 예로 들어보자.

```
abstract class List[+A] 

case class ::[B](var hd: B, var tl: List[B]) extends List[B]

case object Nil extends List[Nothing]
```

`::`는 머리(`hd`, 어떤 타입의 값)와 꼬리(`tl`, 리스트)로 이루어진 리스트이고, 
Nil은 리스트의 끝(또는 아무 원소도 없는 리스트)을 표기하는 특별한 리스트이다. 
앞의 `Option`과 달리 여기서는 `List`가 재귀적으로 정의된다.

또 다른 예로는 나중에 수행할 계산을 보관하기 위한 `Lazy`라는 이름의 클래스를 들 수 있다.

```
class Lazy[T](value: =>T) {
   def getValue():T = value 
}

object Lazy {
   def apply[T](v: =>T):Lazy[T] = 
   {
     new Lazy(v)
   }
}
```

위의 모든 클래스의 공통점은 무엇일까? 
그것은 바로...

```어떤 타입 T에대해 새 클래스의 객체 C[T]를 만드는 생성자 C()가 존재한다```

라는 것이다. 이 조건은 새로운 객체를 생성하기 위해서는 반드시 필요한 조건이다. 
이 조건을 `C[T] 생성자 존재`라 이름을 붙이자.


## 값을 다른 값으로 변환하기, 변환된 값을 다시 감싸기

프로그래밍은 입력에서 출력까지의 일련의 변환 과정이며, 결국 함수의 조합이라 할 수 있다.
일단은 타입이 바뀌는 경우는 제외하고, 편의를 위해 같은 타입 안에서 일어나는 변환(
당연히 이런 경우에는 타입은 안 바뀌고 값만 바뀐다)만을 살펴보자. 

임의의 `T`에 대해 다루기 보다 가장 단순한 `Int`에 대해 생각해 보자.

어떤 수를 제곱하는 함수를 생각해 보자.

```
def squre(x:Int):Int = x * x
```

이제 앞에서 다뤘던 클래스 C에 대해 `C[Int]` 타입의 값 `v`에 대해 `square`를 적용해  
새로운 `C[Int]` 값을 만들어 내는 함수를 생각해 보자. 


```
// Boxed에 대해 만들어 본 함수
def squareBoxed(x:Boxed[Int]):Boxed[Int] = {
  val v = x.value
  val new_v = square(v)
  Boxed(new_v)
}

def squareOption(x:Option[Int]):Option[Int] = x match {
  case Some(_) => {
    val v = x.unapply()
    val new_v = square(v)
    Some(new_v)
  }
  case None => None
}

```


